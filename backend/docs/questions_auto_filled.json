[
  {
    "_id": "696bf3951be05298b8981bc4",
    "title": "Two Sum",
    "difficulty": "Easy",
    "currentTags": [
      "Array",
      "Hash Table"
    ],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash map to store complements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696bfe992bfdc33a87224c14",
    "title": "Two Sum",
    "difficulty": "Easy",
    "currentTags": [
      "Array",
      "Hash Table"
    ],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash map to store complements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696c7887a81497bafa2bd07b",
    "title": "Two Sum",
    "difficulty": "Easy",
    "currentTags": [
      "Array",
      "Hash Table"
    ],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash map to store complements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca04fb19de9609bf14de1",
    "title": "Maximum Path Sum with K Jumps",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use DFS to track path and sum",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca051b19de9609bf14de9",
    "title": "Same Tree Traversal",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca051b19de9609bf14df1",
    "title": "Maximum Subarray XOR",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca051b19de9609bf14df9",
    "title": "Maximum Activities",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca051b19de9609bf14e01",
    "title": "Coin Change",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 1D DP to track minimum coins for each amount",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca051b19de9609bf14e09",
    "title": "Minimum Cost to Connect All Points",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca051b19de9609bf14e11",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP or memoization with recurrence relation",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca052b19de9609bf14e19",
    "title": "Minimum Cost to Merge Stones",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Split problem, solve subproblems, merge results",
      "canonicalAlgorithms": [
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca052b19de9609bf14e21",
    "title": "Allocate Minimum Number of Pages",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca052b19de9609bf14e29",
    "title": "Maximum Width of Binary Tree with Null Node Consideration",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca052b19de9609bf14e31",
    "title": "Minimum Cost to Reach Last Cell",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca052b19de9609bf14e39",
    "title": "Sum of Powers of Primes",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Mathematics",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Integer overflow",
        "Division by zero",
        "Floating point precision"
      ]
    }
  },
  {
    "_id": "696ca052b19de9609bf14e5c",
    "title": "Minimum Cost to Connect All Cities",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e64",
    "title": "Same Level Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e6c",
    "title": "Check if Array Can Be Sorted with One Swap",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e76",
    "title": "Path Existence in a Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e7e",
    "title": "Check if Sorted",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e86",
    "title": "Node Existence in Preorder Traversal",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e8e",
    "title": "Check if Array is Sorted",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca053b19de9609bf14e96",
    "title": "Palindrome Substring Count",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca054b19de9609bf14e9e",
    "title": "Subarray with Given Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca054b19de9609bf14ea6",
    "title": "Find Peak Element",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca054b19de9609bf14eae",
    "title": "Search Insert Position",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca054b19de9609bf14eb6",
    "title": "Nearly Sorted Array",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca054b19de9609bf14ebe",
    "title": "Merge Sorted Arrays",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "binary_search",
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14ec6",
    "title": "Palindrome Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14ecf",
    "title": "Check if a value exists in a binary tree (Preorder)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14ed7",
    "title": "Minimum Window Substring with k Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14edf",
    "title": "Array Rotation Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14ee7",
    "title": "Activity Selection",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14eef",
    "title": "Cycle Detection in Undirected Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca055b19de9609bf14ef7",
    "title": "K-th Smallest Element After Merging Sorted Arrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca056b19de9609bf14eff",
    "title": "Find First Bad Version",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca056b19de9609bf14f07",
    "title": "Maximum Events Attended II",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca056b19de9609bf14f0f",
    "title": "Maximum Non-Overlapping Activities",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca056b19de9609bf14f17",
    "title": "Maximum Increasing Path Sum in Binary Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca056b19de9609bf14f1f",
    "title": "Path Between Two Nodes",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca056b19de9609bf14f27",
    "title": "Same Level Leaf Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca057b19de9609bf14f2f",
    "title": "Maximum Sum Subarray After Circular Shift",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca057b19de9609bf14f37",
    "title": "Palindrome Substrings",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca057b19de9609bf14f3f",
    "title": "Find Target in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca057b19de9609bf14f47",
    "title": "Minimum Window Substring with Wildcards",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca058b19de9609bf14f4f",
    "title": "Kth Smallest Element in a Sorted Matrix",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca058b19de9609bf14f57",
    "title": "Check if Element Exists (Binary Search)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca058b19de9609bf14f5f",
    "title": "Find First Occurrence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca058b19de9609bf14f67",
    "title": "Check if a value exists in a Binary Tree (Preorder Traversal)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca058b19de9609bf14f6f",
    "title": "Minimum Window Substring with K Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca058b19de9609bf14f77",
    "title": "Path Exists",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca059b19de9609bf14f7f",
    "title": "Maximum Events Attended with Constraints",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca059b19de9609bf14f87",
    "title": "Knapsack",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca059b19de9609bf14f8f",
    "title": "Contains Duplicate",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca059b19de9609bf14f97",
    "title": "Merge K Sorted Arrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "binary_search",
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca059b19de9609bf14f9f",
    "title": "Array Pair Sum Divisibility",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash map to store complements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca059b19de9609bf14fa7",
    "title": "Maximum Events Attended",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05ab19de9609bf14faf",
    "title": "Search in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05ab19de9609bf14fb7",
    "title": "Maximum Width Ramp in Binary Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca05ab19de9609bf14fbf",
    "title": "Path Existence in a Directed Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca05ab19de9609bf14fc7",
    "title": "K-th Largest Element After Sorting Subarrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05ab19de9609bf14fcf",
    "title": "Array Nesting",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05ab19de9609bf14fd7",
    "title": "Minimum Swaps to Group Elements",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05bb19de9609bf14fdf",
    "title": "Array Mountain Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05bb19de9609bf14fe7",
    "title": "Longest Palindromic Subsequence with Wildcards",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05bb19de9609bf14ff1",
    "title": "K-th Smallest Element in a Sorted Matrix",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05bb19de9609bf14ff9",
    "title": "Minimum Window Substring with Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05bb19de9609bf15001",
    "title": "Substring Pattern Matching",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching",
        "binary_search",
        "sliding_window",
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca05bb19de9609bf15009",
    "title": "Check if Element Exists",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15011",
    "title": "K-th Smallest Element After Sorting Subarrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15019",
    "title": "Minimum Difference After k Sort Operations",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15021",
    "title": "Maximum Width of Binary Tree with Null Nodes",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15029",
    "title": "Lemonade Change",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15031",
    "title": "Minimum Cost Path with Forbidden Nodes",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15039",
    "title": "Coin Change Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 1D DP to track minimum coins for each amount",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca05cb19de9609bf15041",
    "title": "Maximum Width of Binary Tree with Same Level Nodes",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca05db19de9609bf15049",
    "title": "Non-overlapping Intervals",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca05db19de9609bf15051",
    "title": "Serialize and Deserialize N-ary Tree to Sum Representation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05db19de9609bf15059",
    "title": "Cycle Detection in a Directed Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca05db19de9609bf15061",
    "title": "Maximum Weighted Matching with Interval Scheduling",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching",
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca05db19de9609bf15069",
    "title": "Check if Two Nodes are Cousins in a Binary Tree",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca05db19de9609bf15071",
    "title": "Find Element in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05eb19de9609bf15079",
    "title": "Path with Maximum Probability",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05eb19de9609bf15081",
    "title": "Maximum Sum Subarray After Circular Shift",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05eb19de9609bf15089",
    "title": "Check if Array is Sorted",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05eb19de9609bf15091",
    "title": "Minimum Swaps to Sort",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05eb19de9609bf15099",
    "title": "Palindrome Substrings",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca05eb19de9609bf150a1",
    "title": "Maximum Activities",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05fb19de9609bf150a9",
    "title": "Find First Occurrence",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05fb19de9609bf150b1",
    "title": "Climbing Stairs",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP or memoization with recurrence relation",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca05fb19de9609bf150b9",
    "title": "Minimum Window Substring with K Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca05fb19de9609bf150c1",
    "title": "Maximum Events Attended II",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05fb19de9609bf150c9",
    "title": "Activity Selection",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca05fb19de9609bf150d1",
    "title": "Search Insert Position",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf150d9",
    "title": "Allocate Minimum Number of Pages",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf150e1",
    "title": "Maximum Subarray XOR",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf150e9",
    "title": "Check if Two Nodes are Cousins",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf150f1",
    "title": "Maximum Subarray Sum After Circular Shift",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf150f9",
    "title": "Palindrome Substring Count",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf15101",
    "title": "Serialize and Deserialize N-ary Tree to Sum Representation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca060b19de9609bf15109",
    "title": "Palindrome Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca061b19de9609bf15111",
    "title": "Maximum Sum Subarray After K Concatenations",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca061b19de9609bf15119",
    "title": "Same Tree Traversal",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca061b19de9609bf15121",
    "title": "Find Target in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca061b19de9609bf15129",
    "title": "Array Rotation Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca061b19de9609bf15131",
    "title": "Cycle Detection in a Directed Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15139",
    "title": "Coin Change Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 1D DP to track minimum coins for each amount",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15141",
    "title": "Minimum Window Substring with All Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15149",
    "title": "Array Partition",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use partition to place pivot correctly",
      "canonicalAlgorithms": [
        "quick_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15151",
    "title": "Lemonade Change",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15159",
    "title": "Maximum Profit with K Transactions",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15161",
    "title": "Cycle Detection in Undirected Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca062b19de9609bf15169",
    "title": "Minimum Difference After K Swaps",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca063b19de9609bf15171",
    "title": "Knapsack Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca063b19de9609bf15179",
    "title": "Merge K Sorted Arrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "binary_search",
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca063b19de9609bf15181",
    "title": "Maximum Non-Overlapping Subarrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca063b19de9609bf15189",
    "title": "Array Transformation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca063b19de9609bf15191",
    "title": "Binary Search Existence",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca063b19de9609bf15199",
    "title": "Path Existence",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151a1",
    "title": "B-Tree Range Query",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "segment_tree"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151a9",
    "title": "Path Exists",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151b1",
    "title": "AVL Tree Range Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search",
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151b9",
    "title": "Trie Prefix Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151c1",
    "title": "Expression Target",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151c9",
    "title": "Path Existence in a Weighted Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca064b19de9609bf151d1",
    "title": "Is Power of Three",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca065b19de9609bf151d9",
    "title": "Minimum Spanning Tree Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca065b19de9609bf151e1",
    "title": "Inversion Count with Range Updates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Build segment tree, query/update in O(log n)",
      "canonicalAlgorithms": [
        "segment_tree",
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca065b19de9609bf151e9",
    "title": "Longest Consecutive Sequence with Limited Modifications",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca065b19de9609bf151f1",
    "title": "Minimum Cost to Merge Stones",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Split problem, solve subproblems, merge results",
      "canonicalAlgorithms": [
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca065b19de9609bf151f9",
    "title": "Kth Smallest Element in a Sorted Matrix",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca066b19de9609bf15201",
    "title": "Maximum Sum Subarray of Size K",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca066b19de9609bf15209",
    "title": "Valid Parentheses with Wildcards",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Use stack for matching and order tracking",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca066b19de9609bf15213",
    "title": "Palindrome Check (Recursive)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca066b19de9609bf1521b",
    "title": "Check if Sorted",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca067b19de9609bf15223",
    "title": "Maximum Events Attended with Constraints",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca067b19de9609bf1522b",
    "title": "Check if Array is Sorted After K Rotations",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca067b19de9609bf15233",
    "title": "Minimum Bottleneck Spanning Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca067b19de9609bf1523b",
    "title": "Palindrome Partitioning",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use partition to place pivot correctly",
      "canonicalAlgorithms": [
        "quick_sort",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca067b19de9609bf15243",
    "title": "Longest Path With Same Value",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca067b19de9609bf1524b",
    "title": "Find Kth Smallest Pair Distance",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca068b19de9609bf15253",
    "title": "Friend Circles",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca068b19de9609bf1525b",
    "title": "Regex Code Generator Validation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca068b19de9609bf15263",
    "title": "Trie Prefix Search",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca068b19de9609bf1526b",
    "title": "Shortest Path with Obstacle Removal",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use Dijkstra for non-negative weights, Bellman-Ford for negative",
      "canonicalAlgorithms": [
        "dijkstra",
        "bellman_ford",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca069b19de9609bf15273",
    "title": "Word Search Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca069b19de9609bf1527b",
    "title": "Expression Evaluation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca069b19de9609bf15283",
    "title": "Pair with Target Difference",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca069b19de9609bf1528b",
    "title": "Path Existence in a Flow Network",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca069b19de9609bf15293",
    "title": "Red-Black Tree Range Count",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca06ab19de9609bf1529b",
    "title": "Symmetric Tree",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca06ab19de9609bf152a3",
    "title": "Is Palindrome (Recursive)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca06ab19de9609bf152ab",
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca06bb19de9609bf152b3",
    "title": "Find Peak Element",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca06bb19de9609bf152bb",
    "title": "Search in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca06cb19de9609bf152c3",
    "title": "Linked List Palindrome",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca06cb19de9609bf152cb",
    "title": "Kth Smallest Element in Two Merged BSTs",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca06cb19de9609bf152d3",
    "title": "Prefix Search in Trie",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca06db19de9609bf152db",
    "title": "Red-Black Tree Range Query",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search",
        "segment_tree"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca06db19de9609bf152e3",
    "title": "Validate Email",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca06db19de9609bf152ed",
    "title": "Red-Black Tree Height Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca06db19de9609bf152f5",
    "title": "MST Edge Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca06db19de9609bf152fd",
    "title": "Power of Two Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca06eb19de9609bf15305",
    "title": "MST Edge Inclusion",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca06eb19de9609bf1530d",
    "title": "Range Product Queries with Updates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca06eb19de9609bf15315",
    "title": "Max Sum Subarray of Size K",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca06eb19de9609bf1531d",
    "title": "Course Schedule Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca06eb19de9609bf15325",
    "title": "B-Tree Contains Key",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca06eb19de9609bf1532d",
    "title": "Knapsack",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca06fb19de9609bf15335",
    "title": "Modular Equation Solver",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca06fb19de9609bf1533d",
    "title": "Word Break II",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca06fb19de9609bf15345",
    "title": "Expression Target Sum",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca06fb19de9609bf1534d",
    "title": "AVL Tree Contains",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca06fb19de9609bf15355",
    "title": "Maximum XOR Subarray",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca06fb19de9609bf1535d",
    "title": "Minimum Cost to Connect All Points II",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca070b19de9609bf15365",
    "title": "Path Between Two Nodes",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca070b19de9609bf1536d",
    "title": "Maximum XOR of Two Numbers in an Array (Trie)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca070b19de9609bf15375",
    "title": "Almost Sorted Array",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca070b19de9609bf1537f",
    "title": "Palindrome Checker (Recursive)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca070b19de9609bf15387",
    "title": "Check if a Graph is a Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca070b19de9609bf1538f",
    "title": "Maximum Rectangular Area in Histogram with Queue",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Maintain monotonic stack to track nearest elements",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf15397",
    "title": "Node Existence in Preorder Traversal",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf1539f",
    "title": "Regex Phone Number Validation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf153a9",
    "title": "B-Tree Search",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf153b1",
    "title": "BST Contains Value",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf153b9",
    "title": "Minimum Cost to Connect All Points",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf153c1",
    "title": "Minimum Difficulty of Job Schedule",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca071b19de9609bf153c9",
    "title": "Minimum Window Substring Count",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca072b19de9609bf153d1",
    "title": "Array Rotation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca072b19de9609bf153d9",
    "title": "Red-Black Tree Search",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca072b19de9609bf153e1",
    "title": "Word Break II - Existence",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca072b19de9609bf153e9",
    "title": "Path Existence in a Network",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf153f1",
    "title": "AVL Tree Height Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf153f9",
    "title": "Regex DFA Simulation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf15403",
    "title": "Subset Sum",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack",
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf1540b",
    "title": "Connected Components Count",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf15413",
    "title": "Range Sum Query - Update a Single Element",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf1541b",
    "title": "BST Range Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca073b19de9609bf15423",
    "title": "Course Scheduling with Prerequisites and Minimum Semester Requirement",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort",
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca074b19de9609bf1542d",
    "title": "Is Power of Four",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca074b19de9609bf15435",
    "title": "Contains Duplicate",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca074b19de9609bf1543d",
    "title": "Connected Components",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca074b19de9609bf15445",
    "title": "Prime Factor Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Mathematics",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find",
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Integer overflow",
        "Division by zero",
        "Floating point precision"
      ]
    }
  },
  {
    "_id": "696ca074b19de9609bf1544d",
    "title": "Array Partitioning",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use partition to place pivot correctly",
      "canonicalAlgorithms": [
        "quick_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf15455",
    "title": "Range Update Range Query with Lazy Propagation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build segment tree, query/update in O(log n)",
      "canonicalAlgorithms": [
        "segment_tree"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf1545d",
    "title": "AVL Tree Height Balance",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf15465",
    "title": "Red-Black Tree Contains",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf1546d",
    "title": "Range Sum Query with Updates",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf15475",
    "title": "Maximum Path Sum in Binary Tree (Recursive)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane",
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf1547d",
    "title": "Maximum Subarray Sum with Divide and Conquer",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "kadane",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca075b19de9609bf15485",
    "title": "Perfect Square Check (Binary Search)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca076b19de9609bf1548d",
    "title": "Contains Value in Linked List",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca076b19de9609bf15495",
    "title": "Minimum Bottleneck Spanning Tree Existence",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca076b19de9609bf1549d",
    "title": "Maximum Non-Overlapping Activities",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca076b19de9609bf154a5",
    "title": "Maximum Water Container Area",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca076b19de9609bf154ad",
    "title": "Word Search",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca076b19de9609bf154b5",
    "title": "Maximum Width Ramp in Binary Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca077b19de9609bf154bd",
    "title": "Shortest Path in a Binary Matrix",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Dijkstra for non-negative weights, Bellman-Ford for negative",
      "canonicalAlgorithms": [
        "dijkstra",
        "bellman_ford"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca077b19de9609bf154c5",
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Use stack for matching and order tracking",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca077b19de9609bf154cd",
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca077b19de9609bf154d5",
    "title": "Array Contains Duplicate",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca077b19de9609bf154dd",
    "title": "Range Sum Query - Update Value",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca077b19de9609bf154e5",
    "title": "Square Root Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca078b19de9609bf154ed",
    "title": "Maximum Subset XOR",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use recursion with include/exclude choices",
      "canonicalAlgorithms": [
        "backtracking",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca078b19de9609bf154f5",
    "title": "Maximum Path Sum in a Binary Tree (Existence)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca078b19de9609bf154fd",
    "title": "Minimum Cost Maximum Flow",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca078b19de9609bf15505",
    "title": "Is Power of Two",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca078b19de9609bf1550d",
    "title": "Non-overlapping Intervals",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca079b19de9609bf15515",
    "title": "Linked List Contains Value",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca079b19de9609bf1551d",
    "title": "Path Existence in a Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca079b19de9609bf15525",
    "title": "Inversion Count",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use modified merge sort to count inversions",
      "canonicalAlgorithms": [
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca079b19de9609bf1552d",
    "title": "Check if a number is a power of 2",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca079b19de9609bf15536",
    "title": "Path with Maximum Probability",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca079b19de9609bf1553e",
    "title": "Regex Engine",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca07ab19de9609bf15546",
    "title": "Bipartite Matching",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca07ab19de9609bf1554e",
    "title": "Maximum Path Sum in Binary Tree (Existence Check)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07ab19de9609bf15556",
    "title": "B-Tree Range Query Count",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "segment_tree"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca07ab19de9609bf1555e",
    "title": "Kth Largest Element",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07ab19de9609bf15566",
    "title": "AVL Tree Contains Value",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca07ab19de9609bf1556e",
    "title": "Check for Duplicates",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07bb19de9609bf15576",
    "title": "Maximum XOR Sum of Subarray",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca07bb19de9609bf1557e",
    "title": "Palindrome Linked List",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca07bb19de9609bf15586",
    "title": "Kth Largest Element in a Union of Sorted Arrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07bb19de9609bf1558e",
    "title": "BST Distance",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca07cb19de9609bf15596",
    "title": "Maximum XOR of Two Numbers in an Array",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use bitwise operations for efficient manipulation",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca07cb19de9609bf1559e",
    "title": "Path Existence with Limited Cost",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07cb19de9609bf155a6",
    "title": "Minimum Window Substring with Wildcards",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07cb19de9609bf155ae",
    "title": "Course Scheduling with Prerequisites and Minimum Credits",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort",
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca07cb19de9609bf155b6",
    "title": "Edge in Minimum Spanning Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca07cb19de9609bf155be",
    "title": "Maximum Events Attended",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07db19de9609bf155c6",
    "title": "Minimum Window Substring with All Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07db19de9609bf155d0",
    "title": "Simple Email Validation",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07db19de9609bf155da",
    "title": "Maximum XOR Sum of Two Subarrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca07db19de9609bf155e2",
    "title": "Nearly Sorted Array",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07db19de9609bf155ea",
    "title": "Maximum Subarray Sum After One Circular Shift",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca07db19de9609bf155f2",
    "title": "Path Existence in a Directed Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca07eb19de9609bf155fa",
    "title": "Single Number II",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07eb19de9609bf15602",
    "title": "Same Level Leaf Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07eb19de9609bf1560a",
    "title": "Check if Number is a Power of Two",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07eb19de9609bf15614",
    "title": "Perfect Power",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07eb19de9609bf1561e",
    "title": "Merge K Sorted Linked Lists (Existence Check)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "merge_sort",
        "divide_conquer",
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca07eb19de9609bf15626",
    "title": "Prefix Search",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07fb19de9609bf1562e",
    "title": "Modular Exponentiation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07fb19de9609bf15636",
    "title": "Course Schedule Completion",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca07fb19de9609bf1563e",
    "title": "Validate Filename",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07fb19de9609bf15648",
    "title": "Longest Path in a Weighted DAG",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca07fb19de9609bf15650",
    "title": "Group Anagrams Count",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Compare character frequency counts",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca07fb19de9609bf15658",
    "title": "Minimum Risk Path in a Terrorist Network",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca080b19de9609bf15660",
    "title": "Subarray with Given Sum",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca080b19de9609bf15668",
    "title": "Merge K Sorted Linked Lists (Check for Cycles)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "merge_sort",
        "divide_conquer",
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca080b19de9609bf15670",
    "title": "Merge Sorted Arrays",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "binary_search",
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca080b19de9609bf15678",
    "title": "Detect Cycle in Undirected Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca080b19de9609bf15680",
    "title": "Check MST Edge",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca080b19de9609bf15688",
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca081b19de9609bf15690",
    "title": "Minimum Cost to Reach Destination in Time",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca081b19de9609bf15698",
    "title": "Inversion Count Range Queries",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use modified merge sort to count inversions",
      "canonicalAlgorithms": [
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca081b19de9609bf156a0",
    "title": "Minimum Fuel Cost After K Stops",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca081b19de9609bf156a8",
    "title": "B-Tree Contains Value",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca081b19de9609bf156b0",
    "title": "Largest Divisible Subset",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use recursion with include/exclude choices",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca081b19de9609bf156b8",
    "title": "Max Consecutive Ones II",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca082b19de9609bf156c0",
    "title": "Prefix Existence in Trie",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca082b19de9609bf156c8",
    "title": "Path in a Grid",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca082b19de9609bf156d0",
    "title": "Word Search in Trie",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca082b19de9609bf156d8",
    "title": "K-th Largest in Sliding Window Threshold",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca082b19de9609bf156e0",
    "title": "Range Sum Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca082b19de9609bf156e8",
    "title": "Friends Circle",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca083b19de9609bf156f0",
    "title": "Same Tree Traversal Sequence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca083b19de9609bf156f8",
    "title": "Course Schedule",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca083b19de9609bf15700",
    "title": "Min Cost Max Flow Assignment",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching",
        "max_flow"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca083b19de9609bf15708",
    "title": "Minimize Malware Spread II",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca083b19de9609bf15710",
    "title": "MST Weight Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca083b19de9609bf15718",
    "title": "Check if Element Exists (Divide and Conquer)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Split problem, solve subproblems, merge results",
      "canonicalAlgorithms": [
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca084b19de9609bf15720",
    "title": "Maximum Subarray Sum After One Operation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca084b19de9609bf15728",
    "title": "Regex Engine Simulation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca084b19de9609bf15732",
    "title": "Longest Consecutive Sequence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca084b19de9609bf1573a",
    "title": "Course Scheduling with Prerequisites and Minimum Semester Requirements",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort",
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca085b19de9609bf15742",
    "title": "Maximum Distinct Elements After K Removals",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca085b19de9609bf1574a",
    "title": "Minimum Fuel Cost After K Modifications",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca085b19de9609bf15752",
    "title": "Maximum Path Sum with K Jumps",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use DFS to track path and sum",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca085b19de9609bf1575a",
    "title": "Range Sum Query",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca085b19de9609bf15762",
    "title": "Maximum Unique Subarray",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca085b19de9609bf1576a",
    "title": "Search Range",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca086b19de9609bf15772",
    "title": "Shortest Path with Obstacle Elimination",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use Dijkstra for non-negative weights, Bellman-Ford for negative",
      "canonicalAlgorithms": [
        "dijkstra",
        "bellman_ford",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca086b19de9609bf1577a",
    "title": "Check if Element Exists",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca086b19de9609bf15782",
    "title": "Path Sum Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use DFS to track path and sum",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca086b19de9609bf1578a",
    "title": "Minimum Risk Path in a Grid",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca086b19de9609bf15792",
    "title": "Bottleneck Minimum Spanning Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca086b19de9609bf1579a",
    "title": "Find Target",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157a2",
    "title": "Complex Password Validator",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157ac",
    "title": "Check if a Number is a Power of Two",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157b4",
    "title": "Maximum Points From Non-Overlapping Line Segments",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157bc",
    "title": "Minimum Cost to Connect All Cities",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157c4",
    "title": "Check if a Value Exists in a Binary Tree (Preorder Traversal)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157cc",
    "title": "Coin Change",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 1D DP to track minimum coins for each amount",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca087b19de9609bf157d4",
    "title": "K-th Smallest Element After Sorting Subarrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca088b19de9609bf157dc",
    "title": "Range Sum Query - BIT",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca088b19de9609bf157e4",
    "title": "Largest Prime Factor",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Mathematics",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Integer overflow",
        "Division by zero",
        "Floating point precision"
      ]
    }
  },
  {
    "_id": "696ca088b19de9609bf157ec",
    "title": "Largest Square Submatrix with Divisible Sum",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca088b19de9609bf157f4",
    "title": "Maximum Sum Subarray with Updates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca088b19de9609bf157fc",
    "title": "Remove Duplicates",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca088b19de9609bf15804",
    "title": "Bitwise AND of Numbers Range",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca089b19de9609bf1580c",
    "title": "Generalized Fibonacci Sequence",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP or memoization with recurrence relation",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca089b19de9609bf15814",
    "title": "Detect Cycle in Linked List",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca089b19de9609bf1581c",
    "title": "Maximum Sum Subarray After Updates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use Kadane's algorithm: max_ending_here vs max_so_far",
      "canonicalAlgorithms": [
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca089b19de9609bf15824",
    "title": "Contains Duplicate Value in Linked List",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map",
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca089b19de9609bf1582c",
    "title": "Longest Consecutive Sequence After Deletions",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca089b19de9609bf15834",
    "title": "Minimum Cost Path with Obstacles",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca08ab19de9609bf1583c",
    "title": "Palindrome Queue Stack",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca08ab19de9609bf15844",
    "title": "Maximum Area Container with K Obstacles",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca08ab19de9609bf1584c",
    "title": "Ransom Note",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca08ab19de9609bf15854",
    "title": "Largest Coprime Divisor",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Mathematics",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Integer overflow",
        "Division by zero",
        "Floating point precision"
      ]
    }
  },
  {
    "_id": "696ca08ab19de9609bf1585c",
    "title": "Minimum Cost Maximum Flow with Node Capacities",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca08bb19de9609bf15864",
    "title": "N-Queens Placement",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca08bb19de9609bf1586c",
    "title": "Range Sum Query with Lazy Propagation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08bb19de9609bf15874",
    "title": "Validate Phone Number",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca08bb19de9609bf1587e",
    "title": "Largest Rectangle in Histogram with Limited Live Stack",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Maintain monotonic stack to track nearest elements",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca08bb19de9609bf15886",
    "title": "Largest Rectangle in Histogram with Queue",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Maintain monotonic stack to track nearest elements",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca08cb19de9609bf1588e",
    "title": "Check if Element Exists (Binary Search)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08cb19de9609bf15896",
    "title": "Longest Palindromic Subsequence with Wildcards",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca08cb19de9609bf158a0",
    "title": "Implement a Phone Directory using Trie",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca08cb19de9609bf158a8",
    "title": "Largest Square Submatrix with Prime Sum",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Mathematics",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Integer overflow",
        "Division by zero",
        "Floating point precision"
      ]
    }
  },
  {
    "_id": "696ca08cb19de9609bf158b0",
    "title": "Search in a Binary Search Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158b8",
    "title": "Stream Median Check",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158c0",
    "title": "Anagram Pair",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Compare character frequency counts",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158c8",
    "title": "Edge in MST",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158d0",
    "title": "Binary Search",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158d8",
    "title": "Regex Crossword Solver",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158e0",
    "title": "Kth Smallest Element in Two BSTs",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08db19de9609bf158e8",
    "title": "Longest Subarray with Limited Difference",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca08eb19de9609bf158f0",
    "title": "Same Level Leaf Nodes",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca08eb19de9609bf158f8",
    "title": "Maximum Subarray Sum After Circular Rotation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca08eb19de9609bf15900",
    "title": "Maximum Overlap Interval",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca08eb19de9609bf15908",
    "title": "Regex-Based Arithmetic Expression Evaluator",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Use regex or character-by-character validation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca08eb19de9609bf15914",
    "title": "Connected Graph",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca08eb19de9609bf1591c",
    "title": "Minimum Cost Perfect Matching",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca08fb19de9609bf15924",
    "title": "Course Scheduling with Prerequisites and Maximum Semester Load",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort",
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca08fb19de9609bf1592c",
    "title": "Path Between Nodes",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca08fb19de9609bf15934",
    "title": "Check if Edge is in MST",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca08fb19de9609bf1593c",
    "title": "Largest Rectangle in Histogram with Queue Constraints",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Maintain monotonic stack to track nearest elements",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca08fb19de9609bf15944",
    "title": "Merge K Sorted Linked Lists (Detect Cycles)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "two_pointers",
        "merge_sort",
        "divide_conquer",
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca08fb19de9609bf1594c",
    "title": "Check Path Existence",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca090b19de9609bf15954",
    "title": "Maximum Area Container After K Modifications",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca090b19de9609bf1595c",
    "title": "Constrained Shortest Path",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Dijkstra for non-negative weights, Bellman-Ford for negative",
      "canonicalAlgorithms": [
        "dijkstra",
        "bellman_ford"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca090b19de9609bf15964",
    "title": "Prefix Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca090b19de9609bf1596c",
    "title": "Prefix Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca090b19de9609bf15974",
    "title": "Word Break II - Find All Combinations",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie",
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca091b19de9609bf1597c",
    "title": "Range Minimum Query with Updates and Range GCD Query",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Mathematics",
      "expectedApproach": "Use mathematical properties and formulas",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Integer overflow",
        "Division by zero",
        "Floating point precision"
      ]
    }
  },
  {
    "_id": "696ca091b19de9609bf15984",
    "title": "Valid Parentheses with Wildcard",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Use stack for matching and order tracking",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca091b19de9609bf1598f",
    "title": "Valid Password",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca091b19de9609bf1599b",
    "title": "Maximum Product of Splitted Binary Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca091b19de9609bf159a3",
    "title": "Longest Substring with At Most K Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca091b19de9609bf159ab",
    "title": "Maximum Path Sum in a Binary Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca092b19de9609bf159b3",
    "title": "Kth Largest Element in a Range",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca092b19de9609bf159bb",
    "title": "Red-Black Tree Root Color",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca092b19de9609bf159c3",
    "title": "Target Sum with Plus or Minus",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca092b19de9609bf159cd",
    "title": "Subset Sum Backtracking",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack",
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca092b19de9609bf159d5",
    "title": "B-Tree Node Search",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca092b19de9609bf159dd",
    "title": "Prefix Check in Word List",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca093b19de9609bf159e7",
    "title": "K-th Smallest in Dynamic AVL Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca093b19de9609bf159f1",
    "title": "Subarray with Given Average",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca093b19de9609bf159f9",
    "title": "Valid Email",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca093b19de9609bf15a01",
    "title": "Subarray Sum",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca093b19de9609bf15a09",
    "title": "Check Subset",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use recursion with include/exclude choices",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca093b19de9609bf15a11",
    "title": "Path Exists in Graph",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca094b19de9609bf15a19",
    "title": "Palindrome Check using Stack and Queue",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca094b19de9609bf15a21",
    "title": "Range Sum Query using Segment Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Build segment tree, query/update in O(log n)",
      "canonicalAlgorithms": [
        "segment_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca094b19de9609bf15a29",
    "title": "Value in Nested List",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca094b19de9609bf15a31",
    "title": "Power of Two Check (Bit Manipulation)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca094b19de9609bf15a39",
    "title": "String Shuffle Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca094b19de9609bf15a41",
    "title": "Subarray Sum Greater Than Target",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a4a",
    "title": "Perfect Number",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a52",
    "title": "Paths with Exactly K Steps",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a5a",
    "title": "Prefix Count in Trie",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a62",
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "kadane"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a6a",
    "title": "Maximum XOR Pair Threshold",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use bitwise operations for efficient manipulation",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a72",
    "title": "Path with Target Weight",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca095b19de9609bf15a7c",
    "title": "Power of Two",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca096b19de9609bf15a84",
    "title": "Check Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca096b19de9609bf15a8c",
    "title": "Maximum Items",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca096b19de9609bf15a94",
    "title": "Power of Four",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca096b19de9609bf15a9e",
    "title": "Unique Characters in String",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca096b19de9609bf15aa6",
    "title": "B-Tree Node Keys Sorted",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca097b19de9609bf15aae",
    "title": "Binary Search - Element Existence",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca097b19de9609bf15ab6",
    "title": "Is AVL Balanced",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca097b19de9609bf15abe",
    "title": "Minimum Window Subarray Sum",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca097b19de9609bf15ac6",
    "title": "Sum of Two Squares",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca097b19de9609bf15ace",
    "title": "K-th Smallest in Rotated Sorted Array with Duplicates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca097b19de9609bf15ad7",
    "title": "Count Inversions",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use modified merge sort to count inversions",
      "canonicalAlgorithms": [
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca098b19de9609bf15adf",
    "title": "Balanced Parentheses",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Use stack for matching and order tracking",
      "canonicalAlgorithms": [
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca098b19de9609bf15ae7",
    "title": "Target Sum Subset",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack",
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca098b19de9609bf15aef",
    "title": "Subarrays with K Distinct Elements (Sliding Window)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca098b19de9609bf15af7",
    "title": "Validate Simplified IP Address",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca098b19de9609bf15b04",
    "title": "StartsWith",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca098b19de9609bf15b0e",
    "title": "Target Sum Subset Exists",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack",
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca099b19de9609bf15b16",
    "title": "Difference Pair",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca099b19de9609bf15b1e",
    "title": "Pair Sum in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash map to store complements",
      "canonicalAlgorithms": [
        "hash_map",
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca099b19de9609bf15b26",
    "title": "Project Allocation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca099b19de9609bf15b2e",
    "title": "Valid B-Tree Node Keys Count",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca09ab19de9609bf15b36",
    "title": "Topological Sortable Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca09ab19de9609bf15b3e",
    "title": "Find First Bad Version (Boolean)",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09ab19de9609bf15b46",
    "title": "Prefix and Suffix Search",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09ab19de9609bf15b4f",
    "title": "Shortest Path Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Dijkstra for non-negative weights, Bellman-Ford for negative",
      "canonicalAlgorithms": [
        "dijkstra",
        "bellman_ford"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca09ab19de9609bf15b57",
    "title": "Sortable by Reversal",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09ab19de9609bf15b5f",
    "title": "Prefix Sum Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca09bb19de9609bf15b69",
    "title": "Maximum Distinct Elements in Constrained Sliding Window",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca09bb19de9609bf15b71",
    "title": "Smaller Elements to the Right",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09bb19de9609bf15b79",
    "title": "Peak Array",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09bb19de9609bf15b86",
    "title": "Spanning Tree Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca09bb19de9609bf15b8e",
    "title": "Scrambled String",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use memoization with string indices",
      "canonicalAlgorithms": [
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15b96",
    "title": "String Starts and Ends with Pattern",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15ba5",
    "title": "Red-Black Tree Black Height Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15bad",
    "title": "Recursive Array Search",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Define base case and recursive relation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15bb5",
    "title": "Valid B-Tree Node Children Count",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15bbd",
    "title": "B-Tree Node Split Check",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15bc6",
    "title": "Prefix Word Detection",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09cb19de9609bf15bd3",
    "title": "Maximum Bipartite Matching",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca09db19de9609bf15bdb",
    "title": "Structurally Identical AVL Trees",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca09db19de9609bf15be3",
    "title": "Zig-Zag Path Sum in Binary Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca09db19de9609bf15beb",
    "title": "Element in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca09db19de9609bf15bf3",
    "title": "Coin Change Possibility",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 1D DP to track minimum coins for each amount",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca09db19de9609bf15bfb",
    "title": "Path Existence in Network",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09db19de9609bf15c03",
    "title": "Target Profit Knapsack",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca09eb19de9609bf15c0b",
    "title": "Prefix Check in Word List using Trie",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie",
        "dp_1d",
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca09eb19de9609bf15c15",
    "title": "Significant Inversions",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use modified merge sort to count inversions",
      "canonicalAlgorithms": [
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca09eb19de9609bf15c1d",
    "title": "Friend Circle",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09eb19de9609bf15c25",
    "title": "Range Sum Query Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca09eb19de9609bf15c2d",
    "title": "String Contains Only Digits",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09eb19de9609bf15c35",
    "title": "Value in Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09fb19de9609bf15c3d",
    "title": "Smallest Element Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09fb19de9609bf15c45",
    "title": "Value in Linked List",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca09fb19de9609bf15c4d",
    "title": "License Plate Validator",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca09fb19de9609bf15c56",
    "title": "K-th Smallest in Rotated Sorted Array",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca09fb19de9609bf15c5f",
    "title": "XOR Range Sum",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca09fb19de9609bf15c67",
    "title": "Maximum Profit Scheduling",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c6f",
    "title": "Limited Turns Path in Grid",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c77",
    "title": "Path in Grid",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c7f",
    "title": "Prefix Count Threshold",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c87",
    "title": "String Starts With",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c8f",
    "title": "Same Number of Set Bits",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c97",
    "title": "Search in Binary Search Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a0b19de9609bf15c9f",
    "title": "Deep Copy Linked List with Random Pointers",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0a1b19de9609bf15ca7",
    "title": "Rotated Sorted Array with Duplicates - Minimum Index",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a1b19de9609bf15cb2",
    "title": "Red-Black Tree Validation",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a1b19de9609bf15cba",
    "title": "Non-decreasing Array with One Modification",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a1b19de9609bf15cc4",
    "title": "Substring with At Least K Vowels",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a1b19de9609bf15ccc",
    "title": "Path in a Maze",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path in unweighted graph",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a1b19de9609bf15cd4",
    "title": "Array Contains Element (Recursive)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Define base case and recursive relation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca0a2b19de9609bf15cdc",
    "title": "Anagram Checker with Cleaning",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Compare character frequency counts",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca0a2b19de9609bf15ce4",
    "title": "Find Maximum",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a2b19de9609bf15cec",
    "title": "String Starts and Ends With",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a2b19de9609bf15cf4",
    "title": "Vowel Count",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a2b19de9609bf15cfc",
    "title": "Valid BST Preorder Traversal",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a3b19de9609bf15d06",
    "title": "Subarray with Target Sum (Sliding Window)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "dp_knapsack"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca0a3b19de9609bf15d0e",
    "title": "City Connectivity After Road Construction",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a3b19de9609bf15d18",
    "title": "Array Subset",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use recursion with include/exclude choices",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca0a3b19de9609bf15d20",
    "title": "Grid Path with Teleporters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use 2D DP to count/track paths",
      "canonicalAlgorithms": [
        "dp_2d",
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a3b19de9609bf15d28",
    "title": "Valid Email Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a3b19de9609bf15d30",
    "title": "B-Tree Key Search",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a4b19de9609bf15d38",
    "title": "Alternating Path in Colored Graph",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a4b19de9609bf15d40",
    "title": "Search in BST",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a4b19de9609bf15d49",
    "title": "Minimum Spanning Tree Weight Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a4b19de9609bf15d51",
    "title": "String Transformation by Reversal",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a4b19de9609bf15d5b",
    "title": "Word Break Trie",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie",
        "dp_1d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca0a5b19de9609bf15d65",
    "title": "Jump Game",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a5b19de9609bf15d6d",
    "title": "Path Exists in Graph (DFS)",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a5b19de9609bf15d75",
    "title": "Smallest Element Threshold",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a5b19de9609bf15d7d",
    "title": "Cycle Detection in Directed Graph",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a5b19de9609bf15d85",
    "title": "Reach the End",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a5b19de9609bf15d8d",
    "title": "Remove Nth Node From End",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0a6b19de9609bf15d96",
    "title": "Sort by Reversal",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a6b19de9609bf15da0",
    "title": "Closest Pair of Points",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a6b19de9609bf15da8",
    "title": "Valid Preorder BST",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a6b19de9609bf15db2",
    "title": "Path Existence in Graph",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a6b19de9609bf15dba",
    "title": "Range Update Point Query",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build segment tree, query/update in O(log n)",
      "canonicalAlgorithms": [
        "segment_tree"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a6b19de9609bf15dc2",
    "title": "Path Existence in Undirected Graph",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15dca",
    "title": "Subarray Sum Target",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15dd2",
    "title": "Count Substrings with K Distinct Characters",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15dda",
    "title": "Check Even or Odd",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15de3",
    "title": "Product Code Validator",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15df0",
    "title": "Search in Merged Sorted Lists",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use two pointers moving towards each other or same direction",
      "canonicalAlgorithms": [
        "two_pointers",
        "binary_search",
        "merge_sort",
        "divide_conquer",
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15df8",
    "title": "Word Break with Trie",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie",
        "dp_1d"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca0a7b19de9609bf15e00",
    "title": "Check Subarray Elements",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a8b19de9609bf15e08",
    "title": "Duplicate Check with BIT",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a8b19de9609bf15e10",
    "title": "Negative Cycle Detection in a Graph",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "bellman_ford"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a8b19de9609bf15e18",
    "title": "Word Break Count",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca0a8b19de9609bf15e20",
    "title": "Valid Topological Sort",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a8b19de9609bf15e28",
    "title": "Common Element in Sorted Arrays",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a8b19de9609bf15e30",
    "title": "String Contains Substring",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a9b19de9609bf15e3a",
    "title": "Range Existence Query",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0a9b19de9609bf15e42",
    "title": "Maze Path",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path in unweighted graph",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a9b19de9609bf15e4a",
    "title": "Maximum Distinct Characters in Substring Range",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0a9b19de9609bf15e52",
    "title": "Red-Black Tree Validity After Insertions",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0a9b19de9609bf15e5a",
    "title": "Treasure Path in Grid",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0a9b19de9609bf15e64",
    "title": "Is AVL Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0aab19de9609bf15e6c",
    "title": "Search in Mountain Array",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0aab19de9609bf15e76",
    "title": "Course Schedule Validation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0aab19de9609bf15e7e",
    "title": "Is Binary Min Heap",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Maintain heap property through sift up/down operations",
      "canonicalAlgorithms": [
        "heap_priority_queue"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0aab19de9609bf15e86",
    "title": "Task Assignment",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0aab19de9609bf15e8e",
    "title": "Array Rearrangement",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0aab19de9609bf15e96",
    "title": "Subarray Divisibility",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15e9e",
    "title": "Array Rotation Match",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15ea7",
    "title": "B-Tree Key Existence",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15eaf",
    "title": "Anagram Subarrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Compare character frequency counts",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15eb7",
    "title": "Prefix Check in Trie",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build trie from words, traverse for queries",
      "canonicalAlgorithms": [
        "trie"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15ebf",
    "title": "Spanning Tree Edge Count",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kruskal with Union-Find or Prim with priority queue",
      "canonicalAlgorithms": [
        "kruskal_prim",
        "union_find"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15ec7",
    "title": "Symmetric Tree Traversal",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0abb19de9609bf15ecf",
    "title": "Palindrome Check with Stack and Queue",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Stacks & Queues",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers",
        "monotonic_stack"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Stack underflow",
        "Queue empty check",
        "Wrong order of operations"
      ]
    }
  },
  {
    "_id": "696ca0acb19de9609bf15ed7",
    "title": "Path Sum in Grid (Recursive)",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS to track path and sum",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "backtracking",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0acb19de9609bf15edf",
    "title": "Connected Nodes",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0acb19de9609bf15ee7",
    "title": "Topological Sort Possible",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0acb19de9609bf15eef",
    "title": "Recursive Sum",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Define base case and recursive relation",
      "canonicalAlgorithms": [
        "backtracking"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca0acb19de9609bf15ef7",
    "title": "Non-Overlapping Intervals",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca0acb19de9609bf15eff",
    "title": "Is Valid AVL Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0adb19de9609bf15f07",
    "title": "Valid IPv4 Address",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0adb19de9609bf15f11",
    "title": "Red-Black Tree Color Validation",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0adb19de9609bf15f19",
    "title": "First Bad Version",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0adb19de9609bf15f21",
    "title": "Valid Red-Black Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0adb19de9609bf15f29",
    "title": "Range Sum Greater Than Target",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0adb19de9609bf15f31",
    "title": "K-th Smallest Element in AVL Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0aeb19de9609bf15f39",
    "title": "Range Update Sort Check",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Build segment tree, query/update in O(log n)",
      "canonicalAlgorithms": [
        "segment_tree"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0aeb19de9609bf15f41",
    "title": "Path in Undirected Graph",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0aeb19de9609bf15f49",
    "title": "Portal Path",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Model teleporters as zero-cost edges in BFS",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0aeb19de9609bf15f53",
    "title": "Range Maximum Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0aeb19de9609bf15f5d",
    "title": "Search in Rotated Sorted Array with Duplicates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0aeb19de9609bf15f68",
    "title": "Evaluate Expression",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15f74",
    "title": "K-th Smallest Element in Two Sorted Arrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15f7e",
    "title": "Phone Number Validator",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15f86",
    "title": "Max Vowels in Substring",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15f8e",
    "title": "Anagram Checker with Variations",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Compare character frequency counts",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15f96",
    "title": "Recursive Word Break",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Recursion",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie",
        "backtracking"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Missing base case",
        "Stack overflow on large input",
        "Redundant recursive calls"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15f9e",
    "title": "Valid B-Tree Node",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0afb19de9609bf15fa6",
    "title": "Sorted Array Verification with Swaps",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b0b19de9609bf15faf",
    "title": "Range Significant Inversions",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use modified merge sort to count inversions",
      "canonicalAlgorithms": [
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b0b19de9609bf15fb7",
    "title": "Red-Black Tree Validator",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0b0b19de9609bf15fbf",
    "title": "Valid Username Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b0b19de9609bf15fcc",
    "title": "Are Nodes Connected?",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0b0b19de9609bf15fd4",
    "title": "Find Closest Element",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf15fdc",
    "title": "String Starts With Prefix",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf15fe4",
    "title": "Maximum Subarray Sum of Size K",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "kadane"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf15fec",
    "title": "Maximum Fruits in Two Baskets",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf15ff4",
    "title": "Shortest Path within Limit",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Dijkstra for non-negative weights, Bellman-Ford for negative",
      "canonicalAlgorithms": [
        "dijkstra",
        "bellman_ford"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf15ffc",
    "title": "Treasure Hunt in a Grid",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf16004",
    "title": "Prefix Sum Query",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Precompute prefix sums for O(1) range queries",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b1b19de9609bf1600c",
    "title": "Is Valid Red-Black Tree",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Validate red-black properties: root black, no red-red, equal black height",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0b2b19de9609bf16014",
    "title": "Inversion Count Threshold",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use modified merge sort to count inversions",
      "canonicalAlgorithms": [
        "merge_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b2b19de9609bf1601c",
    "title": "Value in Binary Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0b2b19de9609bf16024",
    "title": "Subarray with Given Sum Threshold",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b2b19de9609bf1602c",
    "title": "Bitwise XOR and Set Bits",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca0b2b19de9609bf16036",
    "title": "System of Congruences",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b2b19de9609bf1603f",
    "title": "Stock Trading with Cooldown",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Track best buy point and max profit",
      "canonicalAlgorithms": [
        "dp_1d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca0b3b19de9609bf16047",
    "title": "Path to Node in a Tree",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use slow/fast pointers or iterative traversal",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0b3b19de9609bf1604f",
    "title": "Search Element in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b3b19de9609bf16057",
    "title": "Peak Element in Mountain Array",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b3b19de9609bf16064",
    "title": "Increasing Path in Grid",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS/DFS for path finding or DP for counting",
      "canonicalAlgorithms": [
        "bfs_dfs",
        "dp_2d"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b3b19de9609bf1606c",
    "title": "Check Minimum",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b3b19de9609bf16074",
    "title": "Validate Tree Traversal",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Use recursive or iterative traversal",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0b4b19de9609bf1607c",
    "title": "Rotatable Array Partition",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use partition to place pivot correctly",
      "canonicalAlgorithms": [
        "quick_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b4b19de9609bf16084",
    "title": "K-th Smallest Element Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b4b19de9609bf1608d",
    "title": "Word Break Backtracking",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie",
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca0b4b19de9609bf16095",
    "title": "Cycle Length in Linked List",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0b4b19de9609bf1609d",
    "title": "Check for Duplicates in Sorted Array",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search",
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b4b19de9609bf160a5",
    "title": "Jump Game Lite",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b5b19de9609bf160ad",
    "title": "Task Scheduling",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca0b5b19de9609bf160b5",
    "title": "Graph Connectivity Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Union-Find for connectivity queries or BFS/DFS",
      "canonicalAlgorithms": [
        "union_find",
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b5b19de9609bf160bd",
    "title": "Substring Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b5b19de9609bf160c5",
    "title": "Repeated Substring Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Leverage BST property: left < root < right",
      "canonicalAlgorithms": [
        "binary_search",
        "sliding_window"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b5b19de9609bf160cd",
    "title": "Maximum Non-overlapping Intervals",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Greedy",
      "expectedApproach": "Sort by end time and select non-overlapping",
      "canonicalAlgorithms": [
        "greedy"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Assuming local optimal is global optimal",
        "Not sorting correctly",
        "Missing edge cases"
      ]
    }
  },
  {
    "_id": "696ca0b5b19de9609bf160d5",
    "title": "Word Break Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Dynamic Programming",
      "expectedApproach": "Use DP to check breakable prefixes",
      "canonicalAlgorithms": [
        "dp_1d",
        "trie"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect base case",
        "Wrong state transition",
        "Not handling boundary conditions"
      ]
    }
  },
  {
    "_id": "696ca0b6b19de9609bf160dd",
    "title": "Unique Elements",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b6b19de9609bf160e5",
    "title": "Carmichael Number Test",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b6b19de9609bf160ef",
    "title": "Course Schedule with Time Limit",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use Kahn's algorithm or DFS for topological ordering",
      "canonicalAlgorithms": [
        "topological_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b6b19de9609bf160f7",
    "title": "Subarray Sum Divisible by K",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b6b19de9609bf160ff",
    "title": "Path in Graph (DFS)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path, DFS for existence",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b6b19de9609bf16107",
    "title": "Selective Linked List Merge",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "divide_conquer",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0b7b19de9609bf16113",
    "title": "Equation Consistency",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b7b19de9609bf16120",
    "title": "Binary Search Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use binary search to eliminate half each iteration",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b7b19de9609bf16128",
    "title": "Palindrome Array Check",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Strings",
      "expectedApproach": "Check characters from both ends towards center",
      "canonicalAlgorithms": [
        "two_pointers"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not handling empty string",
        "Case sensitivity issues",
        "Off-by-one in substring"
      ]
    }
  },
  {
    "_id": "696ca0b7b19de9609bf16132",
    "title": "Escape from the Labyrinth",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use BFS for shortest path in unweighted graph",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b7b19de9609bf1613c",
    "title": "B-Tree Validity Check",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check node degree constraints and key ordering",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0b7b19de9609bf16144",
    "title": "Can Sum",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b8b19de9609bf1614c",
    "title": "Find Maximum using Divide and Conquer",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Split problem, solve subproblems, merge results",
      "canonicalAlgorithms": [
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca0b8b19de9609bf16154",
    "title": "K-th Smallest Element in a Sorted Matrix",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b8b19de9609bf1615c",
    "title": "Range K-th Smallest with Range Updates",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Build segment tree, query/update in O(log n)",
      "canonicalAlgorithms": [
        "segment_tree",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b8b19de9609bf16164",
    "title": "Range Greater Than K Query",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b8b19de9609bf1616c",
    "title": "Detect Cycle in Directed Graph",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Use DFS with visited states or Union-Find",
      "canonicalAlgorithms": [
        "bfs_dfs"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0b8b19de9609bf16174",
    "title": "Array Reversal Equality",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b9b19de9609bf1617c",
    "title": "Range with K Set Bits",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Bit Manipulation",
      "expectedApproach": "Use BIT for prefix sum queries and point updates",
      "canonicalAlgorithms": [
        "fenwick_tree",
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Sign bit issues",
        "Overflow in shift operations",
        "Wrong mask application"
      ]
    }
  },
  {
    "_id": "696ca0b9b19de9609bf16184",
    "title": "Character in String",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b9b19de9609bf1618c",
    "title": "Equation and Inequality Consistency",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  },
  {
    "_id": "696ca0b9b19de9609bf16194",
    "title": "K-th Largest in Sliding Window",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use two pointers with expand/contract window",
      "canonicalAlgorithms": [
        "sliding_window",
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0b9b19de9609bf1619c",
    "title": "Count Subsets with Sum K",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Backtracking",
      "expectedApproach": "Use 0/1 or unbounded knapsack DP",
      "canonicalAlgorithms": [
        "dp_knapsack",
        "backtracking"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not reverting state after recursion",
        "Missing pruning conditions",
        "Duplicate results"
      ]
    }
  },
  {
    "_id": "696ca0b9b19de9609bf161a4",
    "title": "Validate AVL Tree",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Trees",
      "expectedApproach": "Check balance factor and perform rotations",
      "canonicalAlgorithms": [
        "binary_search"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Null pointer on empty tree",
        "Not handling single node case",
        "Incorrect parent-child relationship"
      ]
    }
  },
  {
    "_id": "696ca0bab19de9609bf161ac",
    "title": "K-th Smallest in Merged Arrays",
    "difficulty": "Hard",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort",
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n²) or O(n log n) or O(V+E)",
      "spaceComplexityHint": "O(n) or O(n²)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca0bab19de9609bf161b6",
    "title": "Linked List Cycle Detection",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Linked Lists",
      "expectedApproach": "Use DP with binary search for O(n log n)",
      "canonicalAlgorithms": [
        "dp_1d",
        "binary_search",
        "two_pointers"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Losing head pointer",
        "Not handling null next",
        "Cycle in modification"
      ]
    }
  },
  {
    "_id": "696ca0bab19de9609bf161be",
    "title": "Task Assignment Feasibility",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Graphs",
      "expectedApproach": "Hungarian algorithm or max flow for bipartite matching",
      "canonicalAlgorithms": [
        "bipartite_matching"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Not marking visited nodes",
        "Incorrect adjacency list construction",
        "Stack overflow in DFS"
      ]
    }
  },
  {
    "_id": "696ca0bab19de9609bf161c6",
    "title": "Kth Largest Element Check",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use quickselect or heap for kth element",
      "canonicalAlgorithms": [
        "heap_priority_queue",
        "quick_sort"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0bab19de9609bf161ce",
    "title": "Unique Numbers",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Arrays",
      "expectedApproach": "Use hash set to track seen elements",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Off-by-one errors in indices",
        "Not handling empty array",
        "Integer overflow in sum"
      ]
    }
  },
  {
    "_id": "696ca0bab19de9609bf161d6",
    "title": "Check if Array is Sorted (Divide and Conquer)",
    "difficulty": "Easy",
    "currentTags": [],
    "inferred": {
      "topic": "Divide and Conquer",
      "expectedApproach": "Split problem, solve subproblems, merge results",
      "canonicalAlgorithms": [
        "divide_conquer"
      ],
      "timeComplexityHint": "O(n)",
      "spaceComplexityHint": "O(1) or O(n)",
      "commonMistakes": [
        "Incorrect merge step",
        "Not handling odd/even length",
        "Infinite recursion"
      ]
    }
  },
  {
    "_id": "696ca0bbb19de9609bf161de",
    "title": "Ceiling of a Number",
    "difficulty": "Medium",
    "currentTags": [],
    "inferred": {
      "topic": "General",
      "expectedApproach": "Analyze problem constraints and choose appropriate data structure",
      "canonicalAlgorithms": [
        "hash_map"
      ],
      "timeComplexityHint": "O(n log n) or O(n²)",
      "spaceComplexityHint": "O(n)",
      "commonMistakes": [
        "Check edge cases",
        "Handle empty input",
        "Watch for off-by-one errors"
      ]
    }
  }
]